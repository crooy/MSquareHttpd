


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Software Transactional Memory (Scala) &mdash; Akka Documentation</title>
    <link rel="stylesheet" href="../_static/akka.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Scala API" href="index.html" />
    <link rel="next" title="Transactors (Scala)" href="transactors.html" />
    <link rel="prev" title="Agents (Scala)" href="agents.html" /> 
  </head>
  <body>
      <div class="header"><a href="../index.html"><img class="leftlogo" src="../_static/logo.png" alt="Logo"/></a><h1 class="heading"><a href="../index.html"><span>Akka Documentation</span></a></h1>
       <h2 class="heading"><a href="../index.html"><span>Version 1.2</span></a></h2>
       <h2 class="rightheading"><span><a href="http://akka.io/docs/akka/snapshot/Akka.pdf">PDF</a></span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="agents.html">Agents (Scala)</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="transactors.html">Transactors (Scala)</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="software-transactional-memory-scala">
<span id="stm-scala"></span><h1>Software Transactional Memory (Scala)<a class="headerlink" href="#software-transactional-memory-scala" title="Permalink to this headline">¶</a></h1>
<div class="sidebar">
<p class="first sidebar-title">Contents</p>
<div class="contents local last topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#overview-of-stm" id="id1">Overview of STM</a></li>
<li><a class="reference internal" href="#simple-example" id="id2">Simple example</a></li>
<li><a class="reference internal" href="#ref" id="id3">Ref</a><ul>
<li><a class="reference internal" href="#creating-a-ref" id="id4">Creating a Ref</a></li>
<li><a class="reference internal" href="#accessing-the-value-of-a-ref" id="id5">Accessing the value of a Ref</a></li>
<li><a class="reference internal" href="#changing-the-value-of-a-ref" id="id6">Changing the value of a Ref</a></li>
<li><a class="reference internal" href="#refs-in-for-comprehensions" id="id7">Refs in for-comprehensions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#transactions" id="id8">Transactions</a><ul>
<li><a class="reference internal" href="#retries" id="id9">Retries</a></li>
<li><a class="reference internal" href="#unexpected-retries" id="id10">Unexpected retries</a></li>
<li><a class="reference internal" href="#coordinated-transactions-and-transactors" id="id11">Coordinated transactions and Transactors</a></li>
<li><a class="reference internal" href="#configuring-transactions" id="id12">Configuring transactions</a></li>
<li><a class="reference internal" href="#transaction-lifecycle-listeners" id="id13">Transaction lifecycle listeners</a></li>
<li><a class="reference internal" href="#blocking-transactions" id="id14">Blocking transactions</a></li>
<li><a class="reference internal" href="#alternative-blocking-transactions" id="id15">Alternative blocking transactions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#transactional-datastructures" id="id16">Transactional datastructures</a></li>
<li><a class="reference internal" href="#persistent-datastructures" id="id17">Persistent datastructures</a></li>
<li><a class="reference internal" href="#ants-simulation-sample" id="id18">Ants simulation sample</a></li>
</ul>
</div>
</div>
<p>Module stability: <strong>SOLID</strong></p>
<div class="section" id="overview-of-stm">
<h2><a class="toc-backref" href="#id1">Overview of STM</a><a class="headerlink" href="#overview-of-stm" title="Permalink to this headline">¶</a></h2>
<p>An <a class="reference external" href="http://en.wikipedia.org/wiki/Software_transactional_memory">STM</a> turns the Java heap into a transactional data set with begin/commit/rollback semantics. Very much like a regular database. It implements the first three letters in ACID; ACI:
* Atomic
* Consistent
* Isolated</p>
<p>Generally, the STM is not needed very often when working with Akka. Some use-cases (that we can think of) are:</p>
<ul class="simple">
<li>When you really need composable message flows across many actors updating their <strong>internal local</strong> state but need them to do that atomically in one big transaction. Might not be often, but when you do need this then you are screwed without it.</li>
<li>When you want to share a datastructure across actors.</li>
<li>When you need to use the persistence modules.</li>
</ul>
<p>Akka’s STM implements the concept in <a class="reference external" href="http://clojure.org/">Clojure’s</a> STM view on state in general. Please take the time to read <a class="reference external" href="http://clojure.org/state">this excellent document</a> and view <a class="reference external" href="http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey">this presentation</a> by Rich Hickey (the genius behind Clojure), since it forms the basis of Akka’s view on STM and state in general.</p>
<p>The STM is based on Transactional References (referred to as Refs). Refs are memory cells, holding an (arbitrary) immutable value, that implement CAS (Compare-And-Swap) semantics and are managed and enforced by the STM for coordinated changes across many Refs. They are implemented using the excellent <a class="reference external" href="http://multiverse.codehaus.org/overview.html">Multiverse STM</a>.</p>
<p>Working with immutable collections can sometimes give bad performance due to extensive copying. Scala provides so-called persistent datastructures which makes working with immutable collections fast. They are immutable but with constant time access and modification. They use structural sharing and an insert or update does not ruin the old structure, hence “persistent”. Makes working with immutable composite types fast. The persistent datastructures currently consist of a Map and Vector.</p>
</div>
<div class="section" id="simple-example">
<h2><a class="toc-backref" href="#id2">Simple example</a><a class="headerlink" href="#simple-example" title="Permalink to this headline">¶</a></h2>
<p>Here is a simple example of an incremental counter using STM. This shows creating a <tt class="docutils literal"><span class="pre">Ref</span></tt>, a transactional reference, and then modifying it within a transaction, which is delimited by <tt class="docutils literal"><span class="pre">atomic</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>

<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="k">def</span> <span class="n">counter</span> <span class="k">=</span> <span class="n">atomic</span> <span class="o">{</span>
  <span class="n">ref</span> <span class="n">alter</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">counter</span>
<span class="c1">// -&gt; 1</span>

<span class="n">counter</span>
<span class="c1">// -&gt; 2</span>
</pre></div>
</div>
</div>
<div class="section" id="ref">
<h2><a class="toc-backref" href="#id3">Ref</a><a class="headerlink" href="#ref" title="Permalink to this headline">¶</a></h2>
<p>Refs (transactional references) are mutable references to values and through the STM allow the safe sharing of mutable data. Refs separate identity from value. To ensure safety the value stored in a Ref should be immutable (they can of course contain refs themselves). The value referenced by a Ref can only be accessed or swapped within a transaction. If a transaction is not available, the call will be executed in its own transaction (the call will be atomic). This is a different approach than the Clojure Refs, where a missing transaction results in an error.</p>
<div class="section" id="creating-a-ref">
<h3><a class="toc-backref" href="#id4">Creating a Ref</a><a class="headerlink" href="#creating-a-ref" title="Permalink to this headline">¶</a></h3>
<p>You can create a Ref with or without an initial value.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>

<span class="c1">// giving an initial value</span>
<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="c1">// specifying a type but no initial value</span>
<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</pre></div>
</div>
</div>
<div class="section" id="accessing-the-value-of-a-ref">
<h3><a class="toc-backref" href="#id5">Accessing the value of a Ref</a><a class="headerlink" href="#accessing-the-value-of-a-ref" title="Permalink to this headline">¶</a></h3>
<p>Use <tt class="docutils literal"><span class="pre">get</span></tt> to access the value of a Ref. Note that if no initial value has been given then the value is initially <tt class="docutils literal"><span class="pre">null</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>

<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="n">ref</span><span class="o">.</span><span class="n">get</span>
<span class="o">}</span>
<span class="c1">// -&gt; 0</span>
</pre></div>
</div>
<p>If there is a chance that the value of a Ref is null then you can use <tt class="docutils literal"><span class="pre">opt</span></tt>, which will create an Option, either Some(value) or None, or you can provide a default value with <tt class="docutils literal"><span class="pre">getOrElse</span></tt>. You can also check for null using <tt class="docutils literal"><span class="pre">isNull</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>

<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="n">ref</span><span class="o">.</span><span class="n">opt</span>            <span class="c1">// -&gt; None</span>
  <span class="n">ref</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>   <span class="c1">// -&gt; 0</span>
  <span class="n">ref</span><span class="o">.</span><span class="n">isNull</span>         <span class="c1">// -&gt; true</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="changing-the-value-of-a-ref">
<h3><a class="toc-backref" href="#id6">Changing the value of a Ref</a><a class="headerlink" href="#changing-the-value-of-a-ref" title="Permalink to this headline">¶</a></h3>
<p>To set a new value for a Ref you can use <tt class="docutils literal"><span class="pre">set</span></tt> (or equivalently <tt class="docutils literal"><span class="pre">swap</span></tt>), which sets the new value and returns the old value.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>

<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="n">ref</span><span class="o">.</span><span class="n">set</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// -&gt; 0</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="n">ref</span><span class="o">.</span><span class="n">get</span>
<span class="o">}</span>
<span class="c1">// -&gt; 5</span>
</pre></div>
</div>
<p>You can also use <tt class="docutils literal"><span class="pre">alter</span></tt> which accepts a function that takes the old value and creates a new value of the same type.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>

<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="n">ref</span> <span class="n">alter</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">5</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// -&gt; 5</span>

<span class="k">val</span> <span class="n">inc</span> <span class="k">=</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="n">ref</span> <span class="n">alter</span> <span class="n">inc</span>
<span class="o">}</span>
<span class="c1">// -&gt; 6</span>
</pre></div>
</div>
</div>
<div class="section" id="refs-in-for-comprehensions">
<h3><a class="toc-backref" href="#id7">Refs in for-comprehensions</a><a class="headerlink" href="#refs-in-for-comprehensions" title="Permalink to this headline">¶</a></h3>
<p>Ref is monadic and can be used in for-comprehensions.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>

<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">value</span> <span class="k">&lt;-</span> <span class="n">ref</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// do something with value</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">anotherRef</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">value1</span> <span class="k">&lt;-</span> <span class="n">ref</span>
    <span class="n">value2</span> <span class="k">&lt;-</span> <span class="n">anotherRef</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// -&gt; Ref(4)</span>

<span class="k">val</span> <span class="n">emptyRef</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">value1</span> <span class="k">&lt;-</span> <span class="n">ref</span>
    <span class="n">value2</span> <span class="k">&lt;-</span> <span class="n">emptyRef</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// -&gt; Ref[Int]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="transactions">
<h2><a class="toc-backref" href="#id8">Transactions</a><a class="headerlink" href="#transactions" title="Permalink to this headline">¶</a></h2>
<p>A transaction is delimited using <tt class="docutils literal"><span class="pre">atomic</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">atomic</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>All changes made to transactional objects are isolated from other changes, all make it or non make it (so failure atomicity) and are consistent. With the AkkaSTM you automatically have the Oracle version of the SERIALIZED isolation level, lower isolation is not possible. To make it fully serialized, set the writeskew property that checks if a writeskew problem is allowed to happen.</p>
<div class="section" id="retries">
<h3><a class="toc-backref" href="#id9">Retries</a><a class="headerlink" href="#retries" title="Permalink to this headline">¶</a></h3>
<p>A transaction is automatically retried when it runs into some read or write conflict, until the operation completes, an exception (throwable) is thrown or when there are too many retries. When a read or writeconflict is encountered, the transaction uses a bounded exponential backoff to prevent cause more contention and give other transactions some room to complete.</p>
<p>If you are using non transactional resources in an atomic block, there could be problems because a transaction can be retried. If you are using print statements or logging, it could be that they are called more than once. So you need to be prepared to deal with this. One of the possible solutions is to work with a deferred or compensating task that is executed after the transaction aborts or commits.</p>
</div>
<div class="section" id="unexpected-retries">
<h3><a class="toc-backref" href="#id10">Unexpected retries</a><a class="headerlink" href="#unexpected-retries" title="Permalink to this headline">¶</a></h3>
<p>It can happen for the first few executions that you get a few failures of execution that lead to unexpected retries, even though there is not any read or writeconflict. The cause of this is that speculative transaction configuration/selection is used. There are transactions optimized for a single transactional object, for 1..n and for n to unlimited. So based on the execution of the transaction, the system learns; it begins with a cheap one and upgrades to more expensive ones. Once it has learned, it will reuse this knowledge. It can be activated/deactivated using the speculative property on the TransactionFactory. In most cases it is best use the default value (enabled) so you get more out of performance.</p>
</div>
<div class="section" id="coordinated-transactions-and-transactors">
<h3><a class="toc-backref" href="#id11">Coordinated transactions and Transactors</a><a class="headerlink" href="#coordinated-transactions-and-transactors" title="Permalink to this headline">¶</a></h3>
<p>If you need coordinated transactions across actors or threads then see <a class="reference internal" href="transactors.html#transactors-scala"><em>Transactors (Scala)</em></a>.</p>
</div>
<div class="section" id="configuring-transactions">
<h3><a class="toc-backref" href="#id12">Configuring transactions</a><a class="headerlink" href="#configuring-transactions" title="Permalink to this headline">¶</a></h3>
<p>It&#8217;s possible to configure transactions. The <tt class="docutils literal"><span class="pre">atomic</span></tt> method can take an implicit or explicit <tt class="docutils literal"><span class="pre">TransactionFactory</span></tt>, which can determine properties of the transaction. A default transaction factory is used if none is specified explicitly or there is no implicit <tt class="docutils literal"><span class="pre">TransactionFactory</span></tt> in scope.</p>
<p>Configuring transactions with an <strong>implicit</strong> <tt class="docutils literal"><span class="pre">TransactionFactory</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">txFactory</span> <span class="k">=</span> <span class="nc">TransactionFactory</span><span class="o">(</span><span class="n">readonly</span> <span class="k">=</span> <span class="kc">true</span><span class="o">)</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="c1">// read only transaction</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Configuring transactions with an <strong>explicit</strong> <tt class="docutils literal"><span class="pre">TransactionFactory</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>

<span class="k">val</span> <span class="n">txFactory</span> <span class="k">=</span> <span class="nc">TransactionFactory</span><span class="o">(</span><span class="n">readonly</span> <span class="k">=</span> <span class="kc">true</span><span class="o">)</span>

<span class="n">atomic</span><span class="o">(</span><span class="n">txFactory</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// read only transaction</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The following settings are possible on a TransactionFactory:</p>
<ul class="simple">
<li>familyName - Family name for transactions. Useful for debugging.</li>
<li>readonly - Sets transaction as readonly. Readonly transactions are cheaper.</li>
<li>maxRetries - The maximum number of times a transaction will retry.</li>
<li>timeout - The maximum time a transaction will block for.</li>
<li>trackReads - Whether all reads should be tracked. Needed for blocking operations.</li>
<li>writeSkew - Whether writeskew is allowed. Disable with care.</li>
<li>blockingAllowed - Whether explicit retries are allowed.</li>
<li>interruptible - Whether a blocking transaction can be interrupted.</li>
<li>speculative - Whether speculative configuration should be enabled.</li>
<li>quickRelease - Whether locks should be released as quickly as possible (before whole commit).</li>
<li>propagation - For controlling how nested transactions behave.</li>
<li>traceLevel - Transaction trace level.</li>
</ul>
<p>You can also specify the default values for some of these options in akka.conf. Here they are with their default values:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">stm</span> <span class="o">{</span>
  <span class="n">fair</span>             <span class="k">=</span> <span class="n">on</span>     <span class="k">#</span> <span class="nc">Should</span> <span class="n">global</span> <span class="n">transactions</span> <span class="n">be</span> <span class="n">fair</span> <span class="n">or</span> <span class="n">non</span><span class="o">-</span><span class="n">fair</span> <span class="o">(</span><span class="n">non</span> <span class="n">fair</span> <span class="k">yield</span> <span class="n">better</span> <span class="n">performance</span><span class="o">)</span>
  <span class="n">max</span><span class="o">-</span><span class="n">retries</span>      <span class="k">=</span> <span class="mi">1000</span>
  <span class="n">timeout</span>          <span class="k">=</span> <span class="mi">5</span>      <span class="k">#</span> <span class="nc">Default</span> <span class="n">timeout</span> <span class="k">for</span> <span class="n">blocking</span> <span class="n">transactions</span> <span class="n">and</span> <span class="n">transaction</span> <span class="n">set</span> <span class="o">(</span><span class="n">in</span> <span class="n">unit</span> <span class="n">defined</span> <span class="n">by</span>
                            <span class="k">#</span>     <span class="n">the</span> <span class="n">time</span><span class="o">-</span><span class="n">unit</span> <span class="n">property</span><span class="o">)</span>
  <span class="n">write</span><span class="o">-</span><span class="n">skew</span>       <span class="k">=</span> <span class="kc">true</span>
  <span class="n">blocking</span><span class="o">-</span><span class="n">allowed</span> <span class="k">=</span> <span class="kc">false</span>
  <span class="n">interruptible</span>    <span class="k">=</span> <span class="kc">false</span>
  <span class="n">speculative</span>      <span class="k">=</span> <span class="kc">true</span>
  <span class="n">quick</span><span class="o">-</span><span class="n">release</span>    <span class="k">=</span> <span class="kc">true</span>
  <span class="n">propagation</span>      <span class="k">=</span> <span class="s">&quot;requires&quot;</span>
  <span class="n">trace</span><span class="o">-</span><span class="n">level</span>      <span class="k">=</span> <span class="s">&quot;none&quot;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>You can also determine at which level a transaction factory is shared or not shared, which affects the way in which the STM can optimise transactions.</p>
<p>Here is a shared transaction factory for all instances of an actor.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor._</span>
<span class="k">import</span> <span class="nn">akka.stm._</span>

<span class="k">object</span> <span class="nc">MyActor</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">txFactory</span> <span class="k">=</span> <span class="nc">TransactionFactory</span><span class="o">(</span><span class="n">readonly</span> <span class="k">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">MyActor.txFactory</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span>
      <span class="n">atomic</span> <span class="o">{</span>
        <span class="c1">// read only transaction</span>
      <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Here&#8217;s a similar example with an individual transaction factory for each instance of an actor.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor._</span>
<span class="k">import</span> <span class="nn">akka.stm._</span>

<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">txFactory</span> <span class="k">=</span> <span class="nc">TransactionFactory</span><span class="o">(</span><span class="n">readonly</span> <span class="k">=</span> <span class="kc">true</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span>
      <span class="n">atomic</span> <span class="o">{</span>
        <span class="c1">// read only transaction</span>
      <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="transaction-lifecycle-listeners">
<h3><a class="toc-backref" href="#id13">Transaction lifecycle listeners</a><a class="headerlink" href="#transaction-lifecycle-listeners" title="Permalink to this headline">¶</a></h3>
<p>It&#8217;s possible to have code that will only run on the successful commit of a transaction, or when a transaction aborts. You can do this by adding <tt class="docutils literal"><span class="pre">deferred</span></tt> or <tt class="docutils literal"><span class="pre">compensating</span></tt> blocks to a transaction.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="n">deferred</span> <span class="o">{</span>
    <span class="c1">// executes when transaction commits</span>
  <span class="o">}</span>
  <span class="n">compensating</span> <span class="o">{</span>
    <span class="c1">// executes when transaction aborts</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="blocking-transactions">
<h3><a class="toc-backref" href="#id14">Blocking transactions</a><a class="headerlink" href="#blocking-transactions" title="Permalink to this headline">¶</a></h3>
<p>You can block in a transaction until a condition is met by using an explicit <tt class="docutils literal"><span class="pre">retry</span></tt>. To use <tt class="docutils literal"><span class="pre">retry</span></tt> you also need to configure the transaction to allow explicit retries.</p>
<p>Here is an example of using <tt class="docutils literal"><span class="pre">retry</span></tt> to block until an account has enough money for a withdrawal. This is also an example of using actors and STM together.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>
<span class="k">import</span> <span class="nn">akka.actor._</span>
<span class="k">import</span> <span class="nn">akka.util.duration._</span>
<span class="k">import</span> <span class="nn">akka.event.EventHandler</span>

<span class="k">type</span> <span class="kt">Account</span> <span class="o">=</span> <span class="nc">Ref</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Transfer</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">Account</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">Account</span><span class="o">,</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">Transferer</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">txFactory</span> <span class="k">=</span> <span class="nc">TransactionFactory</span><span class="o">(</span><span class="n">blockingAllowed</span> <span class="k">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">trackReads</span> <span class="k">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">timeout</span> <span class="k">=</span> <span class="mi">60</span> <span class="n">seconds</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Transfer</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">amount</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">atomic</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">from</span><span class="o">.</span><span class="n">get</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
          <span class="nc">EventHandler</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">&quot;not enough money - retrying&quot;</span><span class="o">)</span>
          <span class="n">retry</span>
        <span class="o">}</span>
        <span class="nc">EventHandler</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">&quot;transferring&quot;</span><span class="o">)</span>
        <span class="n">from</span> <span class="n">alter</span> <span class="o">(</span><span class="k">_</span> <span class="o">-</span> <span class="n">amount</span><span class="o">)</span>
        <span class="n">to</span> <span class="n">alter</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="n">amount</span><span class="o">)</span>
      <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">account1</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="mf">100.0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">account2</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="mf">100.0</span><span class="o">)</span>

<span class="k">val</span> <span class="n">transferer</span> <span class="k">=</span> <span class="nc">Actor</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="k">new</span> <span class="nc">Transferer</span><span class="o">).</span><span class="n">start</span><span class="o">()</span>

<span class="n">transferer</span> <span class="o">!</span> <span class="nc">Transfer</span><span class="o">(</span><span class="n">account1</span><span class="o">,</span> <span class="n">account2</span><span class="o">,</span> <span class="mf">500.0</span><span class="o">)</span>
<span class="c1">// INFO Transferer: not enough money - retrying</span>

<span class="n">atomic</span> <span class="o">{</span> <span class="n">account1</span> <span class="n">alter</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">2000</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">// INFO Transferer: transferring</span>

<span class="n">atomic</span> <span class="o">{</span> <span class="n">account1</span><span class="o">.</span><span class="n">get</span> <span class="o">}</span>
<span class="c1">// -&gt; 1600.0</span>

<span class="n">atomic</span> <span class="o">{</span> <span class="n">account2</span><span class="o">.</span><span class="n">get</span> <span class="o">}</span>
<span class="c1">// -&gt; 600.0</span>

<span class="n">transferer</span><span class="o">.</span><span class="n">stop</span><span class="o">()</span>
</pre></div>
</div>
</div>
<div class="section" id="alternative-blocking-transactions">
<h3><a class="toc-backref" href="#id15">Alternative blocking transactions</a><a class="headerlink" href="#alternative-blocking-transactions" title="Permalink to this headline">¶</a></h3>
<p>You can also have two alternative blocking transactions, one of which can succeed first, with <tt class="docutils literal"><span class="pre">either-orElse</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>
<span class="k">import</span> <span class="nn">akka.actor._</span>
<span class="k">import</span> <span class="nn">akka.util.duration._</span>
<span class="k">import</span> <span class="nn">akka.event.EventHandler</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Branch</span><span class="o">(</span><span class="n">left</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">Brancher</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">txFactory</span> <span class="k">=</span> <span class="nc">TransactionFactory</span><span class="o">(</span><span class="n">blockingAllowed</span> <span class="k">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">trackReads</span> <span class="k">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">timeout</span> <span class="k">=</span> <span class="mi">60</span> <span class="n">seconds</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Branch</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">amount</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">atomic</span> <span class="o">{</span>
        <span class="n">either</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="n">get</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">EventHandler</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">&quot;not enough on left - retrying&quot;</span><span class="o">)</span>
            <span class="n">retry</span>
          <span class="o">}</span>
          <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;going left&quot;</span><span class="o">)</span>
        <span class="o">}</span> <span class="n">orElse</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">right</span><span class="o">.</span><span class="n">get</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">EventHandler</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">&quot;not enough on right - retrying&quot;</span><span class="o">)</span>
            <span class="n">retry</span>
          <span class="o">}</span>
          <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;going right&quot;</span><span class="o">)</span>
        <span class="o">}</span>
      <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">ref1</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">ref2</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="k">val</span> <span class="n">brancher</span> <span class="k">=</span> <span class="nc">Actor</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="k">new</span> <span class="nc">Brancher</span><span class="o">).</span><span class="n">start</span><span class="o">()</span>

<span class="n">brancher</span> <span class="o">!</span> <span class="nc">Branch</span><span class="o">(</span><span class="n">ref1</span><span class="o">,</span> <span class="n">ref2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="c1">// INFO Brancher: not enough on left - retrying</span>
<span class="c1">// INFO Brancher: not enough on right - retrying</span>

<span class="n">atomic</span> <span class="o">{</span> <span class="n">ref2</span> <span class="n">alter</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">// INFO Brancher: not enough on left - retrying</span>
<span class="c1">// INFO Brancher: going right</span>

<span class="n">brancher</span><span class="o">.</span><span class="n">stop</span><span class="o">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="transactional-datastructures">
<h2><a class="toc-backref" href="#id16">Transactional datastructures</a><a class="headerlink" href="#transactional-datastructures" title="Permalink to this headline">¶</a></h2>
<p>Akka provides two datastructures that are managed by the STM.</p>
<ul class="simple">
<li>TransactionalMap</li>
<li>TransactionalVector</li>
</ul>
<p>TransactionalMap and TransactionalVector look like regular mutable datastructures, they even implement the standard Scala &#8216;Map&#8217; and &#8216;RandomAccessSeq&#8217; interfaces, but they are implemented using persistent datastructures and managed references under the hood. Therefore they are safe to use in a concurrent environment. Underlying TransactionalMap is HashMap, an immutable Map but with near constant time access and modification operations. Similarly TransactionalVector uses a persistent Vector. See the Persistent Datastructures section below for more details.</p>
<p>Like managed references, TransactionalMap and TransactionalVector can only be modified inside the scope of an STM transaction.</p>
<p><em>IMPORTANT</em>: There have been some problems reported when using transactional datastructures with &#8216;lazy&#8217; initialization. Avoid that.</p>
<p>Here is how you create these transactional datastructures:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>

<span class="c1">// assuming something like</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Address</span><span class="o">(</span><span class="n">location</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="c1">// using initial values</span>
<span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="nc">TransactionalMap</span><span class="o">(</span><span class="s">&quot;bill&quot;</span> <span class="o">-&gt;</span> <span class="nc">User</span><span class="o">(</span><span class="s">&quot;bill&quot;</span><span class="o">))</span>
<span class="k">val</span> <span class="n">vector</span> <span class="k">=</span> <span class="nc">TransactionalVector</span><span class="o">(</span><span class="nc">Address</span><span class="o">(</span><span class="s">&quot;somewhere&quot;</span><span class="o">))</span>

<span class="c1">// specifying types</span>
<span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="nc">TransactionalMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">User</span><span class="o">]</span>
<span class="k">val</span> <span class="n">vector</span> <span class="k">=</span> <span class="nc">TransactionalVector</span><span class="o">[</span><span class="kt">Address</span><span class="o">]</span>
</pre></div>
</div>
<p>TransactionalMap and TransactionalVector wrap persistent datastructures with transactional references and provide a standard Scala interface. This makes them convenient to use.</p>
<p>Here is an example of using a Ref and a HashMap directly:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.HashMap</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">User</span><span class="o">]())</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">users</span> <span class="k">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">get</span>
  <span class="k">val</span> <span class="n">newUsers</span> <span class="k">=</span> <span class="n">users</span> <span class="o">+</span> <span class="o">(</span><span class="s">&quot;bill&quot;</span> <span class="o">-&gt;</span> <span class="nc">User</span><span class="o">(</span><span class="s">&quot;bill&quot;</span><span class="o">))</span> <span class="c1">// creates a new HashMap</span>
  <span class="n">ref</span><span class="o">.</span><span class="n">swap</span><span class="o">(</span><span class="n">newUsers</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="n">ref</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="s">&quot;bill&quot;</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// -&gt; User(&quot;bill&quot;)</span>
</pre></div>
</div>
<p>Here is the same example using TransactionalMap:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.stm._</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">val</span> <span class="n">users</span> <span class="k">=</span> <span class="nc">TransactionalMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">User</span><span class="o">]</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="n">users</span> <span class="o">+=</span> <span class="s">&quot;bill&quot;</span> <span class="o">-&gt;</span> <span class="nc">User</span><span class="o">(</span><span class="s">&quot;bill&quot;</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">atomic</span> <span class="o">{</span>
  <span class="n">users</span><span class="o">(</span><span class="s">&quot;bill&quot;</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// -&gt; User(&quot;bill&quot;)</span>
</pre></div>
</div>
</div>
<div class="section" id="persistent-datastructures">
<h2><a class="toc-backref" href="#id17">Persistent datastructures</a><a class="headerlink" href="#persistent-datastructures" title="Permalink to this headline">¶</a></h2>
<p>Akka&#8217;s STM should only be used with immutable data. This can be costly if you have large datastructures and are using a naive copy-on-write. In order to make working with immutable datastructures fast enough Scala provides what are called Persistent Datastructures. There are currently two different ones:
* HashMap (<a class="reference external" href="http://www.scala-lang.org/api/current/scala/collection/immutable/HashMap.html">scaladoc</a>)
* Vector (<a class="reference external" href="http://www.scala-lang.org/api/current/scala/collection/immutable/Vector.html">scaladoc</a>)</p>
<p>They are immutable and each update creates a completely new version but they are using clever structural sharing in order to make them almost as fast, for both read and update, as regular mutable datastructures.</p>
<p>This illustration is taken from Rich Hickey&#8217;s presentation. Copyright Rich Hickey 2009.</p>
<img alt="../_images/clojure-trees.png" src="../_images/clojure-trees.png" />
</div>
<div class="section" id="ants-simulation-sample">
<h2><a class="toc-backref" href="#id18">Ants simulation sample</a><a class="headerlink" href="#ants-simulation-sample" title="Permalink to this headline">¶</a></h2>
<p>One fun and very enlightening visual demo of STM, actors and transactional references is the <a class="reference external" href="http://github.com/jboner/akka/tree/master/akka-samples/akka-sample-ants/">Ant simulation sample</a>. I encourage you to run it and read through the code since it&#8217;s a good example of using actors with STM.</p>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="agents.html">Agents (Scala)</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="transactors.html">Transactors (Scala)</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2011, Typesafe Inc.
      Last updated on Sep 19, 2011.
    </div>
  </body>
</html>